# screen_control.py

import pyautogui
import time
import os
import pyperclip
from utils.vision import clicar_em_palavra
from utils.tools import listar_todos_apps_acessiveis, encontrar_app_por_nome
from pywinauto import Desktop
from difflib import SequenceMatcher
from datetime import datetime

# --- DICION√ÅRIO COMPLETO DE TECLAS E SIN√îNIMOS ---
KEY_MAP = {
    # Teclas Principais
    'enter': 'enter', 'enviar': 'enter', 'confirma': 'enter', 'confirmar': 'enter',
    'espa√ßo': 'space', 'space': 'space',
    'backspace': 'backspace', 'voltar': 'backspace', 'apagar': 'backspace', 'excluir': 'backspace',
    'tab': 'tab', 'tabula√ß√£o': 'tab',
    'esc': 'esc', 'escape': 'esc', 'escapar': 'esc',
    'delete': 'delete', 'del': 'delete', 'deletar': 'delete',

    # Teclas de Modifica√ß√£o
    'shift': 'shift', 'shift esquerdo': 'shiftleft', 'shift direito': 'shiftright',
    'ctrl': 'ctrl', 'control': 'ctrl', 'control esquerdo': 'ctrlleft', 'control direito': 'ctrlright',
    'alt': 'alt', 'alt esquerdo': 'altleft', 'alt direito': 'altright',
    'windows': 'win', 'win': 'win', 'tecla windows': 'win', 'iniciar': 'win',

    # Teclas de Navega√ß√£o
    'seta para cima': 'up', 'cima': 'up',
    'seta para baixo': 'down', 'baixo': 'down',
    'seta para esquerda': 'left', 'esquerda': 'left',
    'seta para direita': 'right', 'direita': 'right',
    'home': 'home', 'in√≠cio': 'home',
    'end': 'end', 'fim': 'end',
    'page up': 'pageup', 'p√°gina para cima': 'pageup',
    'page down': 'pagedown', 'p√°gina para baixo': 'pagedown',
    'insert': 'insert', 'inserir': 'insert',

    # Teclas de Fun√ß√£o (F1 a F12)
    'f1': 'f1', 'f2': 'f2', 'f3': 'f3', 'f4': 'f4', 'f5': 'f5', 'f6': 'f6',
    'f7': 'f7', 'f8': 'f8', 'f9': 'f9', 'f10': 'f10', 'f11': 'f11', 'f12': 'f12',

    # Teclas de Bloqueio
    'caps lock': 'capslock', 'fixar mai√∫sculas': 'capslock',
    'num lock': 'numlock',
    'scroll lock': 'scrolllock',

    # Teclado Num√©rico
    'asterisco': '*', 'multiplicar': '*',
    'mais': '+', 'soma': '+',
    'menos': '-', 'subtrair': '-',
    'barra': '/', 'dividir': '/',
    'ponto': '.', 'v√≠rgula': ',',

    # Letras e N√∫meros
    **{chr(i): chr(i) for i in range(97, 123)},  # a-z
    **{str(i): str(i) for i in range(10)},  # 0-9
}


def executar_acao_na_tela(app_falado):
    if not app_falado:
        print("‚ö†Ô∏è Alvo para abrir n√£o especificado.")
        return False

    caminho_app = None
    if "explorer" in app_falado or "arquivos" in app_falado:
        os.system("start explorer")
        caminho_app = "explorer"
    elif app_falado == "configura√ß√µes":
        os.system("start ms-settings:")
        caminho_app = "configura√ß√µes"
    else:
        apps = listar_todos_apps_acessiveis()
        caminho_encontrado = encontrar_app_por_nome(app_falado, apps)
        if caminho_encontrado:
            os.startfile(caminho_encontrado)
            caminho_app = caminho_encontrado

    if caminho_app:
        print(f"üü¢ '{app_falado}' executado. Aguardando a janela aparecer...")
        time.sleep(3)
        try:
            janela_app = pyautogui.getActiveWindow()
            if janela_app:
                janela_app.maximize()
                print("‚úÖ Janela maximizada.")
        except Exception as e:
            print(f"‚ö†Ô∏è N√£o foi poss√≠vel maximizar a janela: {e}")
        return True
    else:
        print(f"‚ùå Nenhum aplicativo correspondente a '{app_falado}' encontrado.")
        return False


def tirar_print():
    """
    Tira um print da tela inteira e salva em uma pasta espec√≠fica com data e hora.
    """
    try:
        pasta_prints = os.path.join(os.path.expanduser('~'), 'Pictures', 'LISA_Prints')
        os.makedirs(pasta_prints, exist_ok=True)
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        nome_arquivo = f"Print_{timestamp}.png"
        caminho_completo = os.path.join(pasta_prints, nome_arquivo)
        pyautogui.screenshot(caminho_completo)
        print(f"üì∏ Print salvo em: {caminho_completo}")
        return caminho_completo
    except Exception as e:
        print(f"ü§Ø Ocorreu um erro ao tentar tirar o print: {e}")
        return None


def copiar_arquivo_selecionado():
    try:
        time.sleep(0.2)
        pyautogui.hotkey('ctrl', 'c')
        print("‚úÖ Comando 'Copiar Arquivo' (Ctrl+C) executado.")
        return True
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao tentar copiar o arquivo: {e}")
        return False


def copiar_caminho_selecionado():
    try:
        time.sleep(0.2)
        pyautogui.hotkey('ctrl', 'shift', 'c')
        time.sleep(0.2)
        caminho_com_aspas = pyperclip.paste()
        caminho_sem_aspas = caminho_com_aspas.strip().strip('"')
        pyperclip.copy(caminho_sem_aspas)
        print("‚úÖ Comando 'Copiar Caminho' executado e limpo.")
        return True
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao tentar copiar o caminho: {e}")
        return False


def colar():
    try:
        pyautogui.hotkey('ctrl', 'v')
        print("üìù Conte√∫do colado.")
        return True
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao tentar colar: {e}")
        return False


def digitar_texto(texto):
    time.sleep(1)
    pyautogui.write(texto, interval=0.05)
    print("‚å®Ô∏è Texto digitado.")


def apertar_tecla(tecla_falada):
    """
    Usa o dicion√°rio KEY_MAP para encontrar a tecla correta e pression√°-la.
    """
    tecla_falada = tecla_falada.lower().strip()

    tecla_real = KEY_MAP.get(tecla_falada)

    if tecla_real:
        pyautogui.press(tecla_real)
        print(f"‚å®Ô∏è Tecla '{tecla_real}' pressionada.")
        return True
    else:
        try:
            pyautogui.press(tecla_falada)
            print(f"‚å®Ô∏è Tecla '{tecla_falada}' pressionada diretamente.")
            return True
        except Exception:
            print(f"‚ùå Tecla '{tecla_falada}' n√£o reconhecida.")
            return False


def rolar_tela(sentido="baixo", quantidade=720):
    """
    Rola a tela de forma suave, dividindo o movimento em pequenos passos.
    """
    # Par√¢metros para a suavidade da anima√ß√£o
    passos = 5  # Reduzido para uma rolagem mais r√°pida
    intervalo = 0.01  # Mantemos o intervalo pequeno para a anima√ß√£o ser fluida

    # Calcula o quanto rolar a cada passo
    rolagem_por_passo = quantidade // passos

    if sentido in ["baixo", "descer", "para baixo", "pra baixo"]:
        print("‚¨áÔ∏è Rolando para baixo...")
        for _ in range(passos):
            pyautogui.scroll(-rolagem_por_passo)
            time.sleep(intervalo)
    elif sentido in ["cima", "subir", "para cima", "pra cima"]:
        print("‚¨ÜÔ∏è Rolando para cima...")
        for _ in range(passos):
            pyautogui.scroll(rolagem_por_passo)
            time.sleep(intervalo)


def fechar_janela_por_nome(nome_janela_falado):
    print(f"üîé Procurando por uma janela parecida com '{nome_janela_falado}' para fechar...")
    try:
        desktop = Desktop(backend="win32")
        janelas = desktop.windows()

        if not janelas:
            print("‚ùå Nenhuma janela aberta encontrada.")
            return None, 0

        melhor_match = {'janela': None, 'score': 0.0, 'titulo': ''}

        for janela in janelas:
            titulo = janela.window_text()
            if titulo and "Program Manager" not in titulo:
                score = SequenceMatcher(None, nome_janela_falado.lower(), titulo.lower()).ratio()
                if score > melhor_match['score']:
                    melhor_match['score'] = score
                    melhor_match['janela'] = janela
                    melhor_match['titulo'] = titulo

        if melhor_match['janela']:
            janela_para_fechar = melhor_match['janela']
            titulo_real = melhor_match['titulo']
            score_final = melhor_match['score']

            print(f"‚úÖ Melhor correspond√™ncia encontrada: '{titulo_real}' (Score: {score_final:.2f}). Fechando...")
            janela_para_fechar.close()
            return titulo_real, score_final
        else:
            print(f"‚ùå Nenhuma janela com t√≠tulo vis√≠vel foi encontrada.")
            return None, 0

    except Exception as e:
        print(f"ü§Ø Ocorreu um erro ao tentar fechar a janela: {e}")
        return None, 0
